import java_cup.runtime.*;
import java.util.ArrayList;

import lexer.*;

parser code {:
    // Connect this parser to a scanner!
    XiLexer lex;
    XiParser(XiLexer lex, ComplexSymbolFactory sf) {
        super(lex, sf);
        this.lex = lex;
    }
:};

/* Terminals (tokens returned by the scanner). */
terminal                        USE, IF, WHILE, ELSE, RETURN, LENGTH;
terminal                        INT, BOOL;
terminal                        LNEG, MULT, HMULT, DIV, MOD, ADD, MINUS;
terminal                        LTE, LT, GTE, GT, EQEQ, EQ, NEQ, LAND, LOR; 
terminal                        LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal                        COLON, SEMICOLON, COMMA, DOT, UNDERSCORE;
terminal    Boolean             TRUE, FALSE; 
terminal    String              IDENTIFIER;
terminal    Long                INTEGER;
terminal    Long                CHAR;
terminal    ArrayList<Long>     STRING;

/* Non terminals */
non terminal    Expr;
non terminal    UnaryOp, BinaryOp;
non terminal    FunctionCall, Args, FArgs; 
non terminal    ArrayCall, IndexList;
non terminal    ArrayElems, FArrayElems;
non terminal    VarDeclr, VarType, FVarType, KeyType;
non terminal    Assign, IDList, FIDList, AssignName, ExprList, FExprList;
non terminal    WhileStmt, IfStmt, ElseStmt;
non terminal    Block, StmtListNoReturn, ReturnStmt, StmtNoReturn, Procedure, Stmt;
non terminal    FunctionDeclr, FunctionDef;
non terminal    ArgsTypeList, FArgsTypeList, ReturnTypeList, FReturnTypeList, ArgsType;
non terminal    UseDeclr, UseDeclarations, FunctionDeclarations;
non terminal    Program;

/* Precedences */

/* The grammar rules */
// Expressions
Expr ::= LPAREN Expr RPAREN
    | Expr UnaryOp Expr
    | Expr BinaryOp Expr
    | FunctionCall
    | ArrayCall
    | LBRACE ArrayElems RBRACE
    | TRUE
    | FALSE
    | INTEGER
    | CHAR
    | STRING
    | IDENTIFIER
    ;

UnaryOp ::= LNEG
    | MINUS 
    ;

BinaryOp ::= MULT
    | HMULT
    | DIV
    | MOD
    | ADD
    | MINUS
    | LTE
    | LT
    | GTE
    | GT
    | EQEQ
    | NEQ
    | LAND
    | LOR
    ;

// Function Calls
FunctionCall ::= IDENTIFIER LPAREN Args RPAREN;

Args ::= 
    | Expr FArgs
    ;

FArgs ::= COMMA Expr
    | COMMA Expr FArgs
    ;

// Array Calls
ArrayCall ::= FunctionCall LBRACK Expr RBRACK IndexList
    | IDENTIFIER LBRACK Expr RBRACK IndexList
    ;

IndexList ::=  
    | IndexList LBRACK Expr RBRACK
    ;

// Array List
ArrayElems ::= 
    | Expr FArrayElems
    ;

FArrayElems ::= 
    | COMMA
    | COMMA Expr FArrayElems
    ;

// Variable Declaration
VarDeclr ::= IDENTIFIER COLON VarType;

VarType ::= VarType LBRACK RBRACK
    | FVarType
    ;

FVarType ::= KeyType
    | FVarType LBRACK EXPR RBRACK
    ;

KeyType ::= INT
    | BOOL
    | CHAR
    ;

// Assignment
Assign ::= IDList EQ ExprList;

IDList ::= AssignName
    | AssignName FIDList
    ;

FIDList ::= 
    | COMMA AssignName FIDList
    ;

AssignName ::= UNDERSCORE
    | IDENTIFIER
    | VarDeclr
    ;

ExprList ::= Expr
    | Expr FExprList
    ;

FExprList ::= 
    | COMMA Expr FExprList
    ;

// While Statement
WhileStmt ::= WHILE Expr Block;

// If Statement
IfStmt ::= IF Expr Block ElseStmt;

ElseStmt ::= 
    | ELSE Expr Block
    ;

// Block
Block ::= Stmt
    | LBRACE StmtListNoReturn RBRACE
    | LBRACE StmtListNoReturn ReturnStmt RBRACE
    ;

StmtListNoReturn ::= 
    | StmtNoReturn StmtList
    ;

ReturnStmt ::= RETURN Expr 
    | RETURN
    ;

StmtNoReturn ::= Assign
    | IfStmt
    | WhileStmt
    | Procedure
    | Block
    | VarDeclr
    | SEMICOLON
    ;

Procedure ::= FunctionCall;

Stmt ::= ReturnStmt
    | StmtNoReturn
    ;

// Function Declaration
FunctionDeclr ::= FunctionInit Block;

FunctionDef ::= IDENTIFIER LPAREN ArgsTypeList RPAREN ReturnTypeList;

ArgsTypeList ::= 
    | IDENTIFIER COLON ArgsType FArgsTypeList
    ;

FArgsTypeList ::= 
    | COMMA IDENTIFIER COLON ArgsType FArgsTypeList
    ;

ReturnTypeList ::= 
    | Type FTypeList
    ;

FReturnTypeList ::= 
    | COMMA Type FTypeList
    ;

ArgsType ::= INT
    | BOOL
    | CHAR
    | ArgsType LBRACK RBRACK
    ;

// Use Declaration
UseDeclr ::= USE IDENTIFIER | UseDeclr SEMICOLON;

// Program
Program ::= UseDeclarations FunctionDeclarations;

UseDeclarations ::= 
    | UseDeclarations UseDeclr
    ;

FunctionDeclarations ::= 
    | FunctionDeclr FunctionDeclarations
    ;