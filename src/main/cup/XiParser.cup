import java_cup.runtime.*;
import java.util.ArrayList;

import lexer.*;
import ast.*;

parser code {:
    // Connect this parser to a scanner!
    XiLexer lex;
    XiParser(XiLexer lex, ComplexSymbolFactory sf) {
        super(lex, sf);
        this.lex = lex;
    }
:};

/* Terminals (tokens returned by the scanner). */
terminal                    USE, IF, WHILE, ELSE, RETURN, LENGTH;
terminal                    INT, BOOL;
terminal                    UMINUS, LNEG, MULT, HMULT, DIV, MOD, ADD, MINUS;
terminal                    LTE, LT, GTE, GT, EQEQ, NEQ, LAND, LOR; 
terminal                    LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal                    EQ, COLON, SEMICOLON, COMMA, /*DOT,*/ UNDERSCORE;
terminal    Boolean         TRUE, FALSE; 
terminal    String          IDENTIFIER;
terminal    Long            INTEGER;
terminal    CharWrapper     CHAR;
terminal    StringWrapper   STRING;

/* Non terminals */
non terminal    Node                Expr;
non terminal    Unary.UnaryType     UnaryOp; 
non terminal    Binary.BinaryType   BinaryOp;
non terminal    Node                FunctionCall;
non terminal    ArrayList<Node>     Args, FArgs; 
non terminal    Node                ArrayCall;
non terminal    ArrayList<Node>     IndexList;
non terminal    ArrayList<Node>     ArrayElems, FArrayElems;
non terminal    Node                VarDeclr, VarType, KeyType;
non terminal    Node                Assign, AssignName;
non terminal    ArrayList<Node>     IDList, FIDList;
non terminal    Node                WhileStmt, IfStmt, ElseStmt;
non terminal    Node                BlockNoReturn, SingleStmtNoReturn, Procedure, StmtNoReturn;
non terminal    ArrayList<Node>     StmtListNoReturn, StmtList;
non terminal    Node                BlockReturn;
non terminal    Node                BlockVoidReturn;
non terminal    ArrayList<Node>     StmtListVoid;
non terminal    Node                FunctionDeclr, FunctionDef;
non terminal    ArrayList<Node>     ArgsTypeList, FArgsTypeList, ReturnTypeList, FReturnTypeList;
non terminal    Node                FunType;
non terminal    Node                ProcedureDeclr, ProcedureDef;
non terminal    Node                UseDeclr;
non terminal    ArrayList<Node>     UseDeclarations, FunctionDeclarations;
non terminal    Node                Program;

/* Precedences */
precedence left     ELSE;
precedence right    LOR;
precedence left     LAND;
precedence left     EQEQ, NEQ;
precedence left     LTE, LT, GTE, GT;
precedence left     ADD, MINUS;
precedence left     MULT, HMULT, DIV, MOD;
precedence left     UMINUS, LNEG;

/* The grammar rules */
start with      ProcedureDeclr;

// Program
Program ::= UseDeclarations:uds FunctionDeclarations:fds
    {:
        RESULT = new Program(udsxleft, uds, fds);
    :}
    ;

// Uses
UseDeclarations ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | UseDeclarations:uds UseDeclr:u
    {:
        ArrayList<Node> useDecs = new ArrayList<Node>();
        useDecs.addAll(uds);
        useDecs.add(u);
        RESULT = useDecs;
    :}
    ;

// Use Declaration
UseDeclr ::= 
    USE:u IDENTIFIER:id
    {:
        RESULT = new Use(uxleft, id);
    :}
    | UseDeclr:ud SEMICOLON
    {:
        RESULT = ud;
    :}
    ;

// Functions
FunctionDeclarations ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | FunctionDeclr:f FunctionDeclarations:fds
    {:
        ArrayList<Node> funDecs = new ArrayList<Node>();
        funDecs.add(f);
        funDecs.addAll(fds);
        RESULT = funDecs;
    :}
    | ProcedureDeclr:f FunctionDeclarations:fds
    {:
        ArrayList<Node> funDecs = new ArrayList<Node>();
        funDecs.add(f);
        funDecs.addAll(fds);
        RESULT = funDecs;
    :}
    ;

// Function and Procedure Declaration
FunctionDeclr ::= 
    FunctionDef:def BlockReturn:block
    {:
        RESULT = new Function(defxleft, (Function) def, block);
    :}
    ;

FunctionDef ::= 
    IDENTIFIER:id LPAREN ArgsTypeList:atl RPAREN ReturnTypeList:rtl
    {:
        RESULT = new Function(idxleft,id,atl,rtl);
    :}
    ;

ProcedureDeclr ::= 
    ProcedureDef:def BlockVoidReturn:block
    {:
        RESULT = new Function(defxleft, (Function) def, block);
    :}
    ;

ProcedureDef ::= 
    IDENTIFIER:id LPAREN ArgsTypeList:atl RPAREN
    {:
        RESULT = new Function(idxleft, id, atl);
    :}
    ;

ArgsTypeList ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | IDENTIFIER:id COLON FunType:type FArgsTypeList:fatl
    {:
        ArrayList<Node> args = new ArrayList<Node>();
        args.add(new Declare(idxleft,new Variable(idxleft,id), type));
        args.addAll(fatl);
        RESULT = args;
    :}
    ;

FArgsTypeList ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | COMMA IDENTIFIER:id COLON FunType:type FArgsTypeList:fatl
    {:
        ArrayList<Node> fargs = new ArrayList<Node>();
        fargs.add(new Declare(idxleft,new Variable(idxleft,id),type));
        fargs.addAll(fatl);
        RESULT = fargs;
    :}
    ;

ReturnTypeList ::= 
    FunType:type FReturnTypeList:frtl
    {:
        ArrayList<Node> returns = new ArrayList<Node>();
        returns.add(type);
        returns.addAll(frtl);
        RESULT = returns;
    :}
    ;

FReturnTypeList ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | COMMA FunType:type FReturnTypeList:frtl
    {:
        ArrayList<Node> freturns = new ArrayList<Node>();
        freturns.add(type);
        freturns.addAll(freturns);
        RESULT = freturns;
    :}
    ;

FunType ::= 
    INT:i
    {:
        RESULT = new Type(ixleft, Type.Primitive.INTEGER);
    :}
    | BOOL:b
    {:
        RESULT = new Type(bxleft, Type.Primitive.BOOLEAN);
    :}
    | FunType:type LBRACK RBRACK
    {:
        RESULT = new Type(typexleft, type);
    :}
    ;

// Return Block
BlockReturn ::= 
    RETURN:r Expr:e
    {:
        RESULT = new Block(rxleft, new Return(rxleft, e));
    :}
    | LBRACE:l StmtList:sl RBRACE:r
    {:
        RESULT = new Block(lxleft, sl);
    :}
    ;

StmtList ::= 
    StmtListNoReturn:slnr
    {:
        RESULT = slnr;
    :}
    | StmtListNoReturn:slnr RETURN:r Expr:e
    {:
        ArrayList<Node> sl = new ArrayList<Node>();
        sl.addAll(slnr);
        sl.add(new Return(rxleft,e));
        RESULT = sl;
    :}
    ;

// Void Return Block
BlockVoidReturn ::= 
    RETURN:r
    {:
        RESULT = new Block(rxleft, new Return(rxleft));
    :}
    | LBRACE:l StmtListVoid:slv RBRACE:r
    {:
        RESULT = new Block(lxleft, slv);
    :}
    ;

StmtListVoid ::= 
    StmtListNoReturn:slnr
    {:
        RESULT = slnr;
    :}
    | StmtListNoReturn:slnr RETURN:r
    {:
        ArrayList<Node> sl = new ArrayList<Node>();
        sl.addAll(slnr);
        sl.add(new Return(rxleft));
        RESULT = sl;
    :}
    ; 

// No Return Block
BlockNoReturn ::= 
    SingleStmtNoReturn:ssnr
    {:
        RESULT = new Block(ssnrxleft, ssnr);
    :}
    | LBRACE StmtListNoReturn:slnr RBRACE
    {:
        RESULT = new Block(slnrxleft, slnr);
    :}
    ;

SingleStmtNoReturn ::= 
    Assign:a
    {:
        RESULT = a;
    :}
    | IfStmt:i
    {:
        RESULT = i;
    :}
    | WhileStmt:w
    {:
        RESULT = w;
    :}
    | Procedure:p
    {:
        RESULT = p;
    :}
    | VarDeclr:v
    {:
        RESULT = v;
    :}
    | SEMICOLON
    ;

Procedure ::= FunctionCall:f
    {:
        RESULT = f;
    :};

StmtListNoReturn ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | StmtNoReturn:snr StmtListNoReturn:slnr
    {:
        ArrayList<Node> stmts = new ArrayList<Node>();
        stmts.add(snr);
        stmts.addAll(slnr);
        RESULT = stmts;
    :}
    ;

StmtNoReturn ::= 
    SingleStmtNoReturn:ssnr
    {:
        RESULT = ssnr;
    :}
    | LBRACE:l StmtList:sl RBRACE:r
    {:
        RESULT = new Block(lxleft, sl);
    :}
    ;

// Function Calls
FunctionCall ::= 
    IDENTIFIER:id LPAREN Args:args RPAREN
        {:
            Variable v = new Variable(idxleft, id);
            RESULT = new Call(idxleft, v, args);
        :}
    | LENGTH:l LPAREN Args:args RPAREN
        {:
            Variable v = new Variable(lxleft, "length");
            RESULT = new Call(lxleft, v, args);
        :}
    ;

Args ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | Expr:e FArgs:fargs
        {:
            ArrayList<Node> args = new ArrayList<Node>();
            args.add(e);
            args.addAll(fargs);
            RESULT = args;
        :}
    ;

FArgs ::= 
    COMMA Expr:e
        {:
            ArrayList<Node> args = new ArrayList<Node>();
            args.add(e);
            RESULT = args;
        :}
    | COMMA Expr:e FArgs:fargs
        {:
            ArrayList<Node> args = new ArrayList<Node>();
            args.add(e);
            args.addAll(fargs);
            RESULT = args;
        :}
    ;

// Array Calls
ArrayCall ::= 
    FunctionCall:fc LBRACK Expr:e RBRACK IndexList:il
        {:
            Index index = new Index(fcxleft, fc,e);
            for(Node n: il) {
                index = new Index(fcxleft, index, n);
            }
            RESULT = index;
        :}
    | IDENTIFIER:id LBRACK Expr:e RBRACK IndexList:il
        {:
            Index index = new Index(idxleft, new Variable(idxleft, id), e);
            for(Node n: il) {
                index = new Index(idxleft, index, n);
            }
            RESULT = index;
        :}
    ;

IndexList ::=
        {:
            RESULT = new ArrayList<Node>();
        :}
    | LBRACK Expr:e RBRACK IndexList:il
        {:
            ArrayList<Node> indexlist = new ArrayList<Node>();
            indexlist.add(e);
            indexlist.addAll(il);
            RESULT = indexlist;
        :}
    ;

// Array List
ArrayElems ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | Expr:e FArrayElems:fae
    {:
        ArrayList<Node> elems = new ArrayList<Node>();
        elems.add(e);
        elems.addAll(fae);
        RESULT = elems;
    :}
    ;

FArrayElems ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | COMMA
    {:
        RESULT = new ArrayList<Node>();
    :}
    | COMMA Expr:e FArrayElems:fae
    {:
        ArrayList<Node> elems = new ArrayList<Node>();
        elems.add(e);
        elems.addAll(fae);
        RESULT = elems;
    :}
    ;

// Variable Declaration
VarDeclr ::= 
    IDENTIFIER:id COLON VarType:type
    {:
        RESULT = new Declare(idxleft, new Variable(idxleft, id), type);
    :};

VarType ::= 
    VarType:type LBRACK RBRACK
    {:
        RESULT = new Type(typexleft, type);
    :}
    | VarType:type LBRACK Expr:e RBRACK
    {:
        RESULT = new Type(typexleft, type, e);
    :}
    | KeyType:type 
    {:
        RESULT = type;
    :}
    ;

KeyType ::= 
    INT:i
    {:
        RESULT = new Type(ixleft, Type.Primitive.INTEGER);
    :}
    | BOOL:b
    {:
        RESULT = new Type(bxleft, Type.Primitive.BOOLEAN);
    :}
    ;

// Assignment
Assign ::= 
    IDList:il EQ Expr:e
    {:
        RESULT = new Assign(ilxleft, new Multiple(ilxleft, il), e);
    :};

IDList ::= 
    AssignName:an FIDList:fl
    {:
        ArrayList<Node> idlist = new ArrayList<Node>();
        idlist.add(an);
        idlist.addAll(fl);
        RESULT = idlist;
    :};

FIDList ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | COMMA AssignName:an FIDList:fl
    {:
        ArrayList<Node> idlist = new ArrayList<Node>();
        idlist.add(an);
        idlist.addAll(fl);
        RESULT = idlist;
    :}
    ;

AssignName ::= 
    UNDERSCORE:u
    {:
        RESULT = new Declare(uxleft);
    :}
    | IDENTIFIER:id
    {:
        RESULT = new Variable(idxleft, id);
    :}
    | ArrayCall:a
    {:
        RESULT = a;
    :}
    | VarDeclr:v
    {:
        RESULT = v;
    :}
    ;

// While Statement
WhileStmt ::= WHILE:w Expr:e BlockNoReturn:block
    {:
        RESULT = new While(wxleft, e, block);
    :};

// If Statement
IfStmt ::= IF:i Expr:e BlockNoReturn:block ElseStmt:el
    {:
        RESULT = new If(ixleft, e, block);
    :}
    ;

ElseStmt ::= 
    | ELSE:el BlockNoReturn:block 
    {:
        RESULT = new Else(elxleft,block);
    :}
    ;

// Expressions
Expr ::= 
    LPAREN Expr:e RPAREN
        {:
            RESULT = e;
        :}
    | UnaryOp:uop Expr:e
        {:
            RESULT = new Unary(uopxleft, uop, e);
        :}
    | Expr:e1 BinaryOp:bop Expr:e2
        {:
            RESULT = new Binary(e1xleft, bop,e1,e2);
        :}
    | FunctionCall:fc
        {:
            RESULT = fc;
        :}
    | ArrayCall:ac
        {:
            RESULT = ac;
        :}
    | LBRACE ArrayElems:ae RBRACE
        {:
            RESULT = new XiArray(aexleft, ae);
        :}
    | TRUE:t
        {:
            RESULT = new XiBool(txleft, t); 
        :}
    | FALSE:f
        {:
            RESULT = new XiBool(fxleft, f);
        :}
    | INTEGER:i
        {:
            RESULT = new XiInt(ixleft, i);
        :}
    | CHAR:c
        {:
            RESULT = new XiChar(cxleft, c.name, c.value);
        :}
    | STRING:s
        {:
            RESULT = new XiString(sxleft, s.name, s.value);
        :}
    | IDENTIFIER:id
        {:
            RESULT = new Variable(idxleft, id);
        :}
    ;

UnaryOp ::= 
    LNEG:l
        {:
            RESULT = Unary.UnaryType.LNEGATE;
        :}
    | MINUS:m
        {:
            RESULT = Unary.UnaryType.INEGATE;
        :}
    %prec UMINUS
    ;

BinaryOp ::= 
    MULT:b
        {:
            RESULT = Binary.BinaryType.TIMES;
        :}
    | HMULT:b
        {:
            RESULT = Binary.BinaryType.HIGH_TIMES;
        :}
    | DIV:b
        {:
            RESULT = Binary.BinaryType.DIVISION;
        :}
    | MOD:b
        {:
            RESULT = Binary.BinaryType.MODULO;
        :}
    | ADD:b
        {:
            RESULT = Binary.BinaryType.PLUS;
        :}
    | MINUS:b
        {:
            RESULT = Binary.BinaryType.MINUS;
        :}
    | LTE:b
        {:
            RESULT = Binary.BinaryType.LE;
        :}
    | LT:b
        {:
            RESULT = Binary.BinaryType.LT;
        :}
    | GTE:b
        {:
            RESULT = Binary.BinaryType.GE;
        :}
    | GT:b
        {:
            RESULT = Binary.BinaryType.GT;
        :}
    | EQEQ:b
        {:
            RESULT = Binary.BinaryType.EQ;
        :}
    | NEQ:b
        {:
            RESULT = Binary.BinaryType.NE;
        :}
    | LAND:b
        {:
            RESULT = Binary.BinaryType.AND;
        :}
    | LOR:b
        {:
            RESULT = Binary.BinaryType.OR;
        :}
    ;