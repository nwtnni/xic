import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.*;

import java.util.List;
import java.util.ArrayList;

import lexer.*;
import ast.*;
import xic.XicException;

parser code {:

    /* Exposed Interface */

    //TODO: throw XicException
    public static Node from(String source, String unit) throws XicException {
        XiLexer lexer = XiLexer.from(source, unit);
        XiParser parser = new XiParser(lexer);
        
        try {
        	return parser.parse().value();
        } catch (XicException xic) {
        	throw xic;
        } catch (Exception e) {
        	throw ParseException.internal(e);
        }
    }

    /* Private Utility Functions */

    private XiLexer lexer;

    private XiParser(XiLexer lexer) {
        super(lexer, lexer.getSymbolFactory());
        this.lexer = lexer;
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws ParseException {
        done_parsing();
        ComplexSymbol sym = (ComplexSymbol) cur_token;
        throw new ParseException(sym);
    }

    public void syntax_error(Symbol cur_token) {}

    private Node evalInt(TempInt expr, boolean negate) throws ParseException {
        try {
            String orig = expr.literal;
            if (negate) {
                expr.literal = "-" + expr.literal;
            }
            return new XiInt(expr.location, Long.valueOf(expr.literal), orig, negate);
        } catch (NumberFormatException ex) {
            throw ParseException.numberFormatException(expr.location, expr.literal);
        }
    }

    private Node evalExpr(Node expr) throws ParseException {
        if (expr instanceof TempInt) {
            return evalInt((TempInt) expr, false);
        }
        return expr;
    }

    private Node evalNegExpr(Location l, Node expr) throws ParseException {
        if (expr instanceof TempInt) {
            expr.location = l;
            return evalInt((TempInt) expr, true);
        }
        return new Unary(l, Unary.Kind.INEGATE, expr);
    }

:};

scan with {: return lexer.nextToken(); :};

/* Terminals (tokens returned by the scanner). */
terminal                    USE, IF, WHILE, ELSE, RETURN, LENGTH;
terminal                    INT, BOOL;
terminal                    UMINUS, LNEG, MULT, HMULT, DIV, MOD, ADD, MINUS;
terminal                    LTE, LT, GTE, GT, EQEQ, NEQ, LAND, LOR; 
terminal                    LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal                    EQ, COLON, SEMICOLON, COMMA, /*DOT,*/ UNDERSCORE;
terminal    Boolean         TRUE, FALSE; 
terminal    String          IDENTIFIER;
terminal    String          INTEGER;
terminal    CharWrapper     CHAR;
terminal    StringWrapper   STRING;
terminal                    FUNCTIONCALL, ARRAYCALL; //TODO ARRAYCALL is implemented via LBRACK

/* Non terminals */
non terminal    Node            Expr;
non terminal    List<Node>      ExprList, FExprList;
non terminal    Node            FnCall;
non terminal    List<Node>      Args, FArgs; 
non terminal    Node            ArrayCall;
non terminal    List<Node>      IndexList;
non terminal    List<Node>      ArrayElems, FArrayElems;
non terminal    Node            VarDeclr, VarType, KeyType;
non terminal    List<Node>      VarTypeIndexList, VarTypeIndexListNoExpr;
non terminal    Node            Assign, SingleAssignName, MultiAssignName;
non terminal    Node            AssignVarDeclr, AssignVarType;
non terminal    List<Node>      IDList, FIDList;
non terminal    Node            WhileStmt, IfStmt, ElseStmt;
non terminal    Node            BlockOptBraces, BlockStmts;
non terminal    Node            SingleStmtNoReturn, StmtNoReturn;
non terminal    List<Node>      StmtListNoReturn;
non terminal    Node            FnDeclr, FnDef;
non terminal    List<Node>      ArgsTypeList, FArgsTypeList, ReturnTypeList, FReturnTypeList;
non terminal    Node            FnType;
non terminal    Node            UseDeclr;
non terminal    List<Node>      UseDeclarations, FnDeclarations;
non terminal    Node            Program;
non terminal                    OptSemicolon;

/* Precedences */
precedence nonassoc     ELSE;
precedence left         LOR;
precedence left         LAND;
precedence left         EQEQ, NEQ;
precedence left         LTE, LT, GTE, GT;
precedence left         ADD, MINUS;
precedence left         MULT, HMULT, DIV, MOD;
precedence right        UMINUS, LNEG;
precedence left         FUNCTIONCALL, LBRACK; //TODO LBRACK is hack to make arraycall precedence work

/* The grammar rules */
start with      Program;

// Optional Semicolon
OptSemicolon ::=
    | SEMICOLON
    ;

// Program
Program ::= UseDeclarations:uds FnDeclr:f FnDeclarations:fds
    {:
        fds.add(0,f);
        RESULT = new Program(udsxleft, uds, fds);
    :}
    ;

// Uses
UseDeclarations ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | UseDeclarations:uds UseDeclr:u
    {:
        uds.add(u);
        RESULT = uds;
    :}
    ;

// Use Declaration
UseDeclr ::= 
    USE:u IDENTIFIER:id OptSemicolon
    {:
        RESULT = new Use(uxleft, id);
    :}
    ;

// Functions
FnDeclarations ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | FnDeclr:f FnDeclarations:fds
    {:
        fds.add(0, f);
        RESULT = fds;
    :}
    ;

// Function and Procedure Declaration
FnDeclr ::= 
    FnDef:def LBRACE:l BlockStmts:block RBRACE
    {:
        //TODO because only 1 lookahead--is it possible to refactor?
        block.location = lxleft;

        RESULT = new Fn(defxleft, (Fn) def, block);
    :}
    ;

FnDef ::= 
    IDENTIFIER:id LPAREN ArgsTypeList:atl RPAREN COLON ReturnTypeList:rtl
    {:
        RESULT = new Fn(idxleft, id, atl, rtl);
    :}
    | IDENTIFIER:id LPAREN ArgsTypeList:atl RPAREN
    {:
        RESULT = new Fn(idxleft, id, atl);
    :}
    ;

ArgsTypeList ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | IDENTIFIER:id COLON FnType:type FArgsTypeList:fatl
    {:
        fatl.add(0, new Declare(idxleft, id, type));
        RESULT = fatl;
    :}
    ;

FArgsTypeList ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | COMMA IDENTIFIER:id COLON FnType:type FArgsTypeList:fatl
    {:
        fatl.add(0, new Declare(idxleft, id, type));
        RESULT = fatl;
    :}
    ;

ReturnTypeList ::= 
    FnType:type FReturnTypeList:frtl
    {:
        frtl.add(0, type);
        RESULT = frtl;
    :}
    ;

FReturnTypeList ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | COMMA FnType:type FReturnTypeList:frtl
    {:
        frtl.add(0, type);
        RESULT = frtl;
    :}
    ;

FnType ::= 
    INT:i
    {:
        RESULT = new XiType(ixleft, "int");
    :}
    | BOOL:b
    {:
        RESULT = new XiType(bxleft, "bool");
    :}
    | FnType:type LBRACK RBRACK
    {:
        RESULT = new XiType(typexleft, type);
    :}
    ;

// Block with braces OR single non-return statement
BlockOptBraces ::=
    LBRACE:l BlockStmts:bs RBRACE
    {:
        bs.location = lxleft;
        RESULT = bs;
    :}
    | SingleStmtNoReturn:ssnr
    {:
        // ArrayList<Node> block = new ArrayList<>();
        // block.add(ssnr);
        // RESULT = new Block(ssnrxleft, block);
        RESULT = ssnr;
    :}
    ;

// Block of statements with possible return at the end
BlockStmts ::= 
    StmtListNoReturn:slnr RETURN:r ExprList:el OptSemicolon
    {:
        if (el.size() == 0) {
        	slnr.add(new Return(rxleft));
        } else {
            slnr.add(new Return(rxleft, el));
        }
        RESULT = new Block(slnr);
    :}
    | StmtListNoReturn:slnr
    {:
        RESULT = new Block(slnr);
    :}
    ;

ExprList ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | Expr:e FExprList:fel
    {:
        fel.add(0, evalExpr(e));
        RESULT = fel;
    :}
    ;

FExprList ::=
    {:
        RESULT = new ArrayList<Node>();
    :}
    | COMMA Expr:e FExprList:fel 
    {:
        fel.add(0, evalExpr(e));
        RESULT = fel;
    :}
    ;

SingleStmtNoReturn ::= 
    Assign:a OptSemicolon
    {:
        RESULT = a;
    :}
    | IfStmt:i
    {:
        RESULT = i;
    :}
    | WhileStmt:w 
    {:
        RESULT = w;
    :}
    | FnCall:p OptSemicolon // Procedure
    {:
        RESULT = p;
    :}
    | VarDeclr:v OptSemicolon
    {:
        RESULT = v;
    :}
    ;

StmtListNoReturn ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | StmtNoReturn:snr StmtListNoReturn:slnr
    {:
        slnr.add(0, snr);
        RESULT = slnr;
    :}
    ;

StmtNoReturn ::= 
    LBRACE:l BlockStmts:block RBRACE OptSemicolon
    {:
        //TODO because only 1 lookahead--is it possible to refactor?
        block.location = lxleft;

        RESULT = block;
    :}
    | SingleStmtNoReturn:ssnr
    {:
        RESULT = ssnr;
    :}
    ;

// Function Calls
FnCall ::= 
    IDENTIFIER:id LPAREN Args:args RPAREN
        {:
            RESULT = new Call(idxleft, id, args);
        :}
        %prec FUNCTIONCALL
    ;

Args ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | Expr:e FArgs:fargs
        {:  
            fargs.add(0, evalExpr(e));
            RESULT = fargs;
        :}
    ;

FArgs ::=
    {:
        RESULT = new ArrayList<Node>();
    :} 
    | COMMA Expr:e FArgs:fargs
        {:
            fargs.add(0, evalExpr(e));
            RESULT = fargs;
        :}
    ;

// Array Calls for LHS of assignment
ArrayCall ::= 
    FnCall:fc LBRACK Expr:e RBRACK IndexList:il
        {:
            il.add(0, evalExpr(e));
            Index index = new Index(fcxleft, fc, il.get(0));
            for(int i =1; i<il.size(); i++) {
                Node n = il.get(i);
                index = new Index(n.location, index, n);
            }
            RESULT = index;
        :}
    | IDENTIFIER:id LBRACK Expr:e RBRACK IndexList:il
        {:
            il.add(0, evalExpr(e));
            Index index = new Index(idxleft, new Var(idxleft, id), il.get(0));
            for(int i =1; i<il.size(); i++) {
                Node n = il.get(i);
                index = new Index(n.location, index, n);
            }
            RESULT = index;
        :}
    ;

IndexList ::=
        {:
            RESULT = new ArrayList<Node>();
        :}
    | LBRACK Expr:e RBRACK IndexList:il
        {:
            il.add(0, evalExpr(e));
            RESULT = il;
        :}
    ;

// Array List
ArrayElems ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | Expr:e FArrayElems:fae
    {:
        fae.add(0, evalExpr(e));
        RESULT = fae;
    :}
    ;

FArrayElems ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | COMMA
    {:
        RESULT = new ArrayList<Node>();
    :}
    | COMMA Expr:e FArrayElems:fae
    {:
        fae.add(0, evalExpr(e));
        RESULT = fae;
    :}
    ;

// Var Declaration
VarDeclr ::= 
    IDENTIFIER:id COLON VarType:type
    {:
        RESULT = new Declare(idxleft, id, type);
    :};


VarType ::= 
    KeyType:type VarTypeIndexList:vtil
    {:
        for(int i=vtil.size()-1; i>=0; i--) {
            if(vtil.get(i) == null){
                type = new XiType(typexleft,type);
            }
            else {
                type = new XiType(typexleft, type, vtil.get(i));
            }
        }
        RESULT = type;
    :}
    ;

VarTypeIndexList ::=
    {:
        RESULT = new ArrayList<Node>();
    :}
    | LBRACK Expr:e RBRACK VarTypeIndexList:vtil
    {:
        vtil.add(0,evalExpr(e));
        RESULT = vtil;
    :}
    | LBRACK RBRACK VarTypeIndexListNoExpr:vtilne
    {:
        vtilne.add(0,null);
        RESULT = vtilne;
    :}
    ;

VarTypeIndexListNoExpr ::=
    {:
        RESULT = new ArrayList<Node>();
    :}
    | LBRACK RBRACK VarTypeIndexListNoExpr:vtilne
    {:
        vtilne.add(0,null);
        RESULT = vtilne;
    :}
    ;

KeyType ::= 
    INT:i
    {:
        RESULT = new XiType(ixleft, "int");
    :}
    | BOOL:b
    {:
        RESULT = new XiType(bxleft, "bool");
    :}
    ;

// Assignment
Assign ::= 
    IDList:il EQ Expr:e
    {:
        RESULT = new Assign(ilxleft, il, evalExpr(e));
    :}
    | SingleAssignName:san EQ Expr:e
    {:
        RESULT = new Assign(sanxleft, san, evalExpr(e));
    :}
    ;

IDList ::= 
    MultiAssignName:an COMMA MultiAssignName:bn FIDList:fl
    {:
        fl.add(0, bn);
        fl.add(0, an);
        RESULT = fl;
    :};

FIDList ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | COMMA MultiAssignName:an FIDList:fl
    {:
        fl.add(0, an);
        RESULT = fl;
    :}
    ;

// LHS of multiple assignment
MultiAssignName ::=
    UNDERSCORE:u
    {:
        RESULT = new Declare(uxleft);
    :}
    | AssignVarDeclr:v
    {:
        RESULT = v;
    :}
    ;

// LHS of single assignment
SingleAssignName ::= 
    UNDERSCORE:u
    {:
        RESULT = new Declare(uxleft);
    :}
    | IDENTIFIER:id
    {:
        RESULT = new Var(idxleft, id);
    :}
    | ArrayCall:a
    {:
        RESULT = a;
    :}
    | AssignVarDeclr:v
    {:
        RESULT = v;
    :}
    ;

AssignVarDeclr ::= 
    IDENTIFIER:id COLON AssignVarType:type 
    {:
        RESULT = new Declare(idxleft, id, type);
    :}
    ;

AssignVarType ::=
    KeyType:type VarTypeIndexListNoExpr:vtilne
    {:
        for(int i=vtilne.size()-1; i>=0; i--) {
            if(vtilne.get(i) == null){
                type = new XiType(typexleft, type);
            }
            else {
                type = new XiType(typexleft, type, vtilne.get(i));
            }
        }
        RESULT = type;
    :}
    ;


// While Statement
WhileStmt ::= WHILE:w Expr:e BlockOptBraces:block
    {:
        RESULT = new While(wxleft, evalExpr(e), block);
    :};

// If Statement
IfStmt ::= IF:i Expr:e BlockOptBraces:block ElseStmt:el
    {:
        If node = (el == null) ? new If(ixleft, evalExpr(e), block) : new If(ixleft, evalExpr(e), block, el);
        RESULT = node;
    :}
    ;

ElseStmt ::= 
    {: 
        RESULT = null;
    :}
    | ELSE:el BlockOptBraces:block 
    {:
        RESULT = block;
    :}
    ;

// Expressions
Expr ::= 
    LPAREN Expr:e RPAREN
        {:
            RESULT = evalExpr(e);
        :}
    | LNEG:l Expr:e
        {:
            RESULT = new Unary(lxleft, Unary.Kind.LNEGATE, evalExpr(e));
        :}
    | MINUS:m Expr:e
        {:
            RESULT = evalNegExpr(mxleft, e);
        :}
        %prec UMINUS
    | Expr:e1 MULT:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.TIMES, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 HMULT:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.HIGH_TIMES, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 DIV:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.DIVISION, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 MOD:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.MODULO, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 ADD:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.PLUS, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 MINUS:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.MINUS, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 LTE:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.LE, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 LT:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.LT, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 GTE:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.GE, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 GT:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.GT, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 EQEQ:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.EQ, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 NEQ:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.NE, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 LAND:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.AND, evalExpr(e1), evalExpr(e2));
        :}
    | Expr:e1 LOR:b Expr:e2
        {:
            RESULT = new Binary(bxleft, Binary.Kind.OR, evalExpr(e1), evalExpr(e2));
        :}
    | FnCall:fc
        {:
            RESULT = fc;
        :}
    | LENGTH:l LPAREN Expr:e RPAREN
        {:
            RESULT = new Call(lxleft, "length", evalExpr(e));
        :}
        %prec FUNCTIONCALL
    | Expr:e1 LBRACK Expr:e2 RBRACK
        {:
            Index index = new Index(e1xleft, evalExpr(e1), evalExpr(e2));
            RESULT = index;
        :}
    | LBRACE ArrayElems:ae RBRACE
        {:
            RESULT = new XiArray(aexleft, ae);
        :}
    | TRUE:t
        {:
            RESULT = new XiBool(txleft, t); 
        :}
    | FALSE:f
        {:
            RESULT = new XiBool(fxleft, f);
        :}
    | INTEGER:i
        {:
            RESULT = new TempInt(ixleft, i);
        :}
    | CHAR:c
        {:
            RESULT = new XiChar(cxleft, c.name, c.value);
        :}
    | STRING:s
        {:
            RESULT = new XiString(sxleft, s.name, s.value);
        :}
    | IDENTIFIER:id
        {:
            RESULT = new Var(idxleft, id);
        :}
    ;
