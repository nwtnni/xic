import java_cup.runtime.*;
import java.util.ArrayList;

import lexer.*;
import ast.*;

parser code {:
    // Connect this parser to a scanner!
    XiLexer lex;
    XiParser(XiLexer lex, ComplexSymbolFactory sf) {
        super(lex, sf);
        this.lex = lex;
    }
:};

scan with {: return lex.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal                    USE, IF, WHILE, ELSE, RETURN, LENGTH;
terminal                    INT, BOOL;
terminal                    UMINUS, LNEG, MULT, HMULT, DIV, MOD, ADD, MINUS;
terminal                    LTE, LT, GTE, GT, EQEQ, NEQ, LAND, LOR; 
terminal                    LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal                    EQ, COLON, SEMICOLON, COMMA, /*DOT,*/ UNDERSCORE;
terminal    Boolean         TRUE, FALSE; 
terminal    String          IDENTIFIER;
terminal    Long            INTEGER;
terminal    CharWrapper     CHAR;
terminal    StringWrapper   STRING;

/* Non terminals */
non terminal    Node                Expr;
non terminal    Node                UnaryOp, BinaryOp;
non terminal    Node                FunctionCall;
non terminal    ArrayList<Node>     Args, FArgs; 
non terminal    Node                ArrayCall, IndexList;
non terminal    ArrayList<Node>     ArrayElems, FArrayElems;
non terminal    Node                VarDeclr, VarType, KeyType;
non terminal    Node                Assign, AssignName;
non terminal    ArrayList<Node>     IDList, FIDList;
non terminal    Node                WhileStmt, IfStmt, ElseStmt;
non terminal    Node                BlockNoReturn, SingleStmtNoReturn, Procedure, StmtNoReturn;
non terminal    ArrayList<Node>     StmtListNoReturn, StmtList;
non terminal    Node                BlockReturn;
non terminal    Node                BlockVoidReturn;
non terminal    ArrayList<Node>     StmtListVoid;
non terminal    Node                FunctionDeclr, FunctionDef;
non terminal    ArrayList<Node>     ArgsTypeList, FArgsTypeList, ReturnTypeList, FReturnTypeList;
non terminal    Node                FunType;
non terminal    Node                ProcedureDeclr, ProcedureDef;
non terminal    Node                UseDeclr;
non terminal    ArrayList<Node>     UseDeclarations, FunctionDeclarations;
non terminal    Node                Program;

/* Precedences */
precedence left     ELSE;
precedence right    LOR;
precedence left     LAND;
precedence left     EQEQ, NEQ;
precedence left     LTE, LT, GTE, GT;
precedence left     ADD, MINUS;
precedence left     MULT, HMULT, DIV, MOD;
precedence left     UMINUS, LNEG;

/* The grammar rules */
start with      Program;

// Expressions
Expr ::= 
    LPAREN Expr:e RPAREN
        {:
            RESULT = e;
        :}
    | UnaryOp:uop Expr:e
        {:
            Unary u = (Unary) uop;
            u.child = e;
            RESULT = u;
        :}
    | Expr:e1 BinaryOp:bop Expr:e2
        {:
            Binary b = (Binary) bop;
            b.lhs = e1;
            b.rhs = e2;
            RESULT = b;
        :}
    | FunctionCall:fc
        {:
            RESULT = fc;
        :}
    | ArrayCall:ac
        {:
            RESULT = ac;
        :}
    | LBRACE ArrayElems:ae RBRACE
        {:
            RESULT = new XiArray(aexleft, ae);
        :}
    | TRUE:t
        {:
            RESULT = new XiBool(txleft, t); 
        :}
    | FALSE:f
        {:
            RESULT = new XiBool(fxleft, f);
        :}
    | INTEGER:i
        {:
            RESULT = new XiInt(ixleft, i);
        :}
    | CHAR:c
        {:
            RESULT = new XiChar(cxleft, c.name, c.value);
        :}
    | STRING:s
        {:
            RESULT = new XiString(sxleft, s.name, s.value);
        :}
    | IDENTIFIER:id
        {:
            RESULT = new Variable(idxleft, id);
        :}
    ;

UnaryOp ::= 
    LNEG:l
        {:
            RESULT = new Unary(lxleft, Unary.UnaryType.LNEGATE, null);
        :}
    | MINUS:m
        {:
            RESULT = new Unary(mxleft, Unary.UnaryType.INEGATE, null);
        :}
    %prec UMINUS
    ;

BinaryOp ::= 
    MULT:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.TIMES, null, null);
        :}
    | HMULT:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.HIGH_TIMES, null, null);
        :}
    | DIV:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.DIVISION, null, null);
        :}
    | MOD:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.MODULO, null, null);
        :}
    | ADD:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.PLUS, null, null);
        :}
    | MINUS:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.MINUS, null, null);
        :}
    | LTE:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.LE, null, null);
        :}
    | LT:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.LT, null, null);
        :}
    | GTE:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.GE, null, null);
        :}
    | GT:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.GT, null, null);
        :}
    | EQEQ:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.EQ, null, null);
        :}
    | NEQ:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.NE, null, null);
        :}
    | LAND:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.AND, null, null);
        :}
    | LOR:b
        {:
            RESULT = new Binary(bxleft, Binary.BinaryType.OR, null, null);
        :}
    ;

// Function Calls
FunctionCall ::= 
    IDENTIFIER:id LPAREN Args:args RPAREN
        {:
            Variable v = new Variable(idxleft, id);
            RESULT = new Call(idxleft, v, args);
        :}
    | LENGTH:l LPAREN Args:args RPAREN
        {:
            Variable v = new Variable(lxleft, "length");
            RESULT = new Call(lxleft, v, args);
        :}
    ;

Args ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | Expr:e FArgs:fargs
        {:
            ArrayList<Node> args = new ArrayList<Node>();
            args.add(e);
            args.addAll(fargs);
            RESULT = args;
        :}
    ;

FArgs ::= 
    COMMA Expr:e
        {:
            ArrayList<Node> args = new ArrayList<Node>();
            args.add(e);
            RESULT = args;
        :}
    | COMMA Expr:e FArgs:fargs
        {:
            ArrayList<Node> args = new ArrayList<Node>();
            args.add(e);
            args.addAll(fargs);
            RESULT = args;
        :}
    ;

// Array Calls
ArrayCall ::= 
    FunctionCall:fc LBRACK Expr:e RBRACK IndexList:il
        {:
            
        :}
    | IDENTIFIER:id LBRACK Expr:e RBRACK IndexList:il
        {:
            // Index arr1 = new Index(idxleft, id, e);
            // if (il != null) {
            //     Index arr2 = (Index) il;
            //     arr2.array = arr1;
            //     RESULT = arr2;
            // } else {
            //     RESULT = arr1;
            // }
        :}
    ;

IndexList ::=
        {:

        :}
    | LBRACK Expr:e RBRACK IndexList:il
        {:
            
        :}
    ;

// Array List
ArrayElems ::= 
    | Expr FArrayElems
    ;

FArrayElems ::= 
    | COMMA
    | COMMA Expr FArrayElems
    ;

// Variable Declaration
VarDeclr ::= IDENTIFIER COLON VarType;

VarType ::= VarType LBRACK RBRACK
    | VarType LBRACK Expr RBRACK
    | KeyType
    ;

KeyType ::= INT
    | BOOL
    ;

// Assignment
Assign ::= IDList EQ Expr;

IDList ::= AssignName FIDList;

FIDList ::= 
    | COMMA AssignName FIDList
    ;

AssignName ::= UNDERSCORE
    | IDENTIFIER
    | ArrayCall
    | VarDeclr
    ;

// While Statement
WhileStmt ::= WHILE Expr BlockNoReturn;

// If Statement
IfStmt ::= IF Expr BlockNoReturn ElseStmt;

ElseStmt ::= 
    | ELSE Expr BlockNoReturn
    ;

// No Return Block
BlockNoReturn ::= SingleStmtNoReturn
    | LBRACE StmtListNoReturn RBRACE
    ;

SingleStmtNoReturn ::= Assign
    | IfStmt
    | WhileStmt
    | Procedure
    | VarDeclr
    | SEMICOLON
    ;

Procedure ::= FunctionCall;

StmtListNoReturn ::= 
    | StmtNoReturn StmtListNoReturn
    ;

StmtNoReturn ::= SingleStmtNoReturn
    | LBRACE StmtList RBRACE
    ;

// Return Block
BlockReturn ::= RETURN Expr
    | LBRACE StmtList RBRACE
    ;

StmtList ::= StmtListNoReturn
    | StmtListNoReturn RETURN Expr
    ;

// Void Return Block
BlockVoidReturn ::= RETURN
    | LBRACE StmtListVoid RBRACE
    ;

StmtListVoid ::= StmtListNoReturn
    | StmtListNoReturn RETURN
    ; 

// Function Declaration
FunctionDeclr ::= FunctionDef BlockReturn;

FunctionDef ::= IDENTIFIER LPAREN ArgsTypeList RPAREN ReturnTypeList;

ArgsTypeList ::= 
    | IDENTIFIER COLON FunType FArgsTypeList
    ;

FArgsTypeList ::= 
    | COMMA IDENTIFIER COLON FunType FArgsTypeList
    ;

ReturnTypeList ::= FunType FReturnTypeList;

FReturnTypeList ::= 
    | COMMA FunType FReturnTypeList
    ;

FunType ::= INT
    | BOOL
    | FunType LBRACK RBRACK
    ;

// Procedure Declaration
ProcedureDeclr ::= ProcedureDef BlockVoidReturn
    ;

ProcedureDef ::= IDENTIFIER LPAREN ArgsTypeList RPAREN
    ;

// Use Declaration
UseDeclr ::= USE IDENTIFIER 
    | UseDeclr SEMICOLON
    ;

// Program
Program ::= UseDeclarations FunctionDeclarations
    ;

UseDeclarations ::= 
    | UseDeclarations UseDeclr
    ;

FunctionDeclarations ::= 
    | FunctionDeclr FunctionDeclarations
    | ProcedureDeclr FunctionDeclarations
    ;
