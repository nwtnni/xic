import java_cup.runtime.*;
import java.util.ArrayList;

import lexer.*;

parser code {:
    // Connect this parser to a scanner!
    XiLexer lex;
    IXiParser(XiLexer lex, ComplexSymbolFactory sf) {
        super(lex, sf);
        this.lex = lex;
    }
:};

/* Terminals (tokens returned by the scanner). */
terminal                    USE, IF, WHILE, ELSE, RETURN, LENGTH;
terminal                    INT, BOOL;
terminal                    UMINUS, LNEG, MULT, HMULT, DIV, MOD, ADD, MINUS;
terminal                    LTE, LT, GTE, GT, EQEQ, NEQ, LAND, LOR; 
terminal                    LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal                    EQ, COLON, SEMICOLON, COMMA, /*DOT,*/ UNDERSCORE;
terminal    Boolean         TRUE, FALSE; 
terminal    String          IDENTIFIER;
terminal    Long            INTEGER;
terminal    CharWrapper     CHAR;
terminal    StringWrapper   STRING;

/* Non terminals */
non terminal    Node                FunctionDef;
non terminal    ArrayList<Node>     FunctionDefList;
non terminal    ArrayList<Node>     ArgsTypeList, FArgsTypeList;
non terminal    ArrayList<Node>     ReturnTypeList, FReturnTypeList;
non terminal    Node                FunType;
non terminal    Node                Interface;

/* The grammar rules */
start with      Interface;

// Function Definitions
FunctionDef ::= 
    IDENTIFIER:id LPAREN ArgsTypeList:atl RPAREN COLON ReturnTypeList:rtl
        {: 
            RESULT = new Function(idxleft, id, atl, rtl, null);
        :}
    ;

ArgsTypeList ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | IDENTIFIER:id COLON FunType:type FArgsTypeList:atl
        {:
            Variable v = new Variable(idxleft, id);
            ArrayList<Node> args = new ArrayList<Node>();
            args.add(new Declare(idxleft, v, type));
            args.addAll(atl);
            RESULT = args;
        :}
    ;

FArgsTypeList ::=
        {:
            RESULT = new ArrayList<Node>();
        :} 
    | COMMA IDENTIFIER:id COLON FunType:type FArgsTypeList:atl
        {:
            Variable v = new Variable(idxleft, id);
            ArrayList<Node> args = new ArrayList<Node>();
            args.add(new Declare(idxleft, v, type));
            args.addAll(atl);
            RESULT = args;
        :}
    ;

ReturnTypeList ::= 
    FunType:type FReturnTypeList:rtl
        {:
            ArrayList<Node> returns = new ArrayList<Node>();
            returns.add(new Type(typexleft, type));
            returns.addAll(rtl);
            RESULT = returns;
        :}
    ;

FReturnTypeList ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | COMMA FunType:type FReturnTypeList:rtl
        {:
            ArrayList<Node> returns = new ArrayList<Node>();
            returns.add(new Type(typexleft, type));
            returns.addAll(rtl);
            RESULT = returns; 
        :}
    ;

FunType ::= 
    INT:i
        {:
            RESULT = new Type(ixleft, Type.Primitive.INTEGER);
        :}
    | BOOL:b
        {:
            RESULT = new Type(bxleft, Type.Primitive.BOOLEAN);
        :}
    | FunType:type LBRACK RBRACK
        {:
            RESULT = new Type(typexleft, type);
        :}
    ;

// Interface
FunctionDefList ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | FunctionDefList:fdl FunctionDef:f
        {:
            ArrayList<Node> funcs = new ArrayList<Node>();
            funcs.addAll(fdl);
            funcs.add(f);
            RESULT = funcs;
        :}
    ;

Interface ::=
    FunctionDefList:fdl
        {:
            RESULT = new Program(fdlxleft, new ArrayList<Node>(), fdl);
        :}
    ;