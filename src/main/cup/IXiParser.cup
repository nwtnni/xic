import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.*;
import java.util.ArrayList;

import lexer.*;
import ast.*;
import xic.XicException;

parser code {:

    /* Exposed Interface */

    //TODO: throw XicException
    public static Node from(String source, String unit) throws XicException {
        IXiLexer lexer = IXiLexer.from(source, unit);
        IXiParser parser = new IXiParser(lexer);
        
        try {
        	return parser.parse().value();
        } catch (XicException xic) {
        	throw xic;
        } catch (Exception e) {
        	throw ParseException.internal(e);
        }
    }

    /* Private Utility Functions */

    IXiLexer lexer;

    IXiParser(IXiLexer lexer) {
        super(lexer, lexer.getSymbolFactory());
        this.lexer = lexer;
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws ParseException {
        done_parsing();
        ComplexSymbol sym = (ComplexSymbol) cur_token;
        throw new ParseException(sym);
    }

    public void syntax_error(Symbol cur_token) {}

:};

scan with {: return lexer.nextToken(); :};

/* Terminals (tokens returned by the scanner). */
terminal                    USE, IF, WHILE, ELSE, RETURN, LENGTH;
terminal                    INT, BOOL;
terminal                    UMINUS, LNEG, MULT, HMULT, DIV, MOD, ADD, MINUS;
terminal                    LTE, LT, GTE, GT, EQEQ, NEQ, LAND, LOR; 
terminal                    LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal                    EQ, COLON, SEMICOLON, COMMA, /*DOT,*/ UNDERSCORE;
terminal    Boolean         TRUE, FALSE; 
terminal    String          IDENTIFIER;
terminal    Long            INTEGER;
terminal    CharWrapper     CHAR;
terminal    StringWrapper   STRING;

/* Non terminals */
non terminal    Node                FnDef, ProcedureDef;
non terminal    ArrayList<Node>     FnDefList;
non terminal    ArrayList<Node>     ArgsTypeList, FArgsTypeList;
non terminal    ArrayList<Node>     ReturnTypeList, FReturnTypeList;
non terminal    Node                FnType;
non terminal    Node                Interface;

/* The grammar rules */
start with      Interface;

// Function Definitions
FnDef ::= 
    IDENTIFIER:id LPAREN ArgsTypeList:atl RPAREN COLON ReturnTypeList:rtl
    {:
        Node args = atl.size() == 1 ? atl.get(0) : new Multiple(atlxleft, atl, Multiple.Kind.FN_ARGS);
        Node returns = rtl.size() == 1 ? rtl.get(0) : new Multiple(rtlxleft, rtl, Multiple.Kind.FN_RETURNS);
        RESULT = new Fn(idxleft, id, args, returns);
    :}
    | IDENTIFIER:id LPAREN ArgsTypeList:atl RPAREN
    {:
        Node args = atl.size() == 1 ? atl.get(0) : new Multiple(atlxleft, atl, Multiple.Kind.FN_ARGS);
        RESULT = new Fn(idxleft, id, args);
    :}
    ;

ArgsTypeList ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | IDENTIFIER:id COLON FnType:type FArgsTypeList:atl
        {:
            atl.add(0, new Declare(idxleft, id, type));
            RESULT = atl;
        :}
    ;

FArgsTypeList ::=
        {:
            RESULT = new ArrayList<Node>();
        :} 
    | COMMA IDENTIFIER:id COLON FnType:type FArgsTypeList:atl
        {:
            atl.add(0, new Declare(idxleft, id, type));
            RESULT = atl;
        :}
    ;

ReturnTypeList ::= 
    FnType:type FReturnTypeList:rtl
        {:
            rtl.add(0, type);
            RESULT = rtl;
        :}
    ;

FReturnTypeList ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | COMMA FnType:type FReturnTypeList:rtl
        {:
            rtl.add(0, type);
            RESULT = rtl;
        :}
    ;

FnType ::= 
    INT:i
        {:
            RESULT = new XiType(ixleft, "int");
        :}
    | BOOL:b
        {:
            RESULT = new XiType(bxleft, "bool");
        :}
    | FnType:type LBRACK RBRACK
        {:
            RESULT = new XiType(typexleft, type);
        :}
    ;

// Interface
FnDefList ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | FnDefList:fdl FnDef:f
        {:
            fdl.add(f);
            RESULT = fdl;
        :}
    ;

Interface ::= FnDef:f FnDefList:fdl
        {:
            fdl.add(0,f);
            RESULT = new Program(fdlxleft, fdl);
        :}
    ;
