import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.*;

import java.util.List;
import java.util.ArrayList;

import lex.*;
import ast.*;
import xic.XicException;

parser code {:

    /* Exposed Interface */

    //TODO: throw XicException
    public static Node from(String source, String unit) throws XicException {
        IXiLexer lexer = IXiLexer.from(source, unit);
        IXiParser parser = new IXiParser(lexer);
        
        try {
        	return parser.parse().value();
        } catch (XicException xic) {
        	throw xic;
        } catch (Exception e) {
        	throw ParseException.internal(e);
        }
    }

    /* Private Utility Functions */

    IXiLexer lexer;

    IXiParser(IXiLexer lexer) {
        super(lexer, lexer.getSymbolFactory());
        this.lexer = lexer;
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws ParseException {
        done_parsing();
        ComplexSymbol sym = (ComplexSymbol) cur_token;
        throw new ParseException(sym);
    }

    public void syntax_error(Symbol cur_token) {}

:};

scan with {: return lexer.nextToken(); :};

/* Terminals (tokens returned by the scanner). */
terminal                    USE;
terminal                    INT, BOOL;
terminal                    LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal                    COLON, COMMA;
terminal    String          IDENTIFIER;
terminal                    CLASS, EXTENDS;                        // New for PA7: THIS, CLASS, EXTENDS, NEW

/* Non terminals */
non terminal    Node            FnSig;
non terminal    List<Node>      FnSigList;
non terminal    List<Node>      ArgsTypeList, FArgsTypeList;
non terminal    List<Node>      ReturnTypeList, FReturnTypeList;
non terminal    Node            FnType;
non terminal    Node            Interface;

/* The grammar rules */
start with      Interface;

// Top level for interface
Interface ::= 
    FnSigList:fdl FnSig:f
    {:
        fdl.add(f);
        RESULT = new XiProgram(fdlxleft, fdl);
    :}
    ;

FnSigList ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | FnSigList:fdl FnSig:f
        {:
            fdl.add(f);
            RESULT = fdl;
        :}
    ;

/* --- Function and procedure declaration --- */

// Function Declarations
FnSig ::= 
    IDENTIFIER:id LPAREN ArgsTypeList:atl RPAREN COLON ReturnTypeList:rtl
    {:
        RESULT = new XiFn(idxleft, id, atl, rtl);
    :}
    | IDENTIFIER:id LPAREN ArgsTypeList:atl RPAREN
    {:
        RESULT = new XiFn(idxleft, id, atl);
    :}
    ;

ArgsTypeList ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | IDENTIFIER:id COLON FnType:type FArgsTypeList:atl
        {:
            atl.add(0, new XiDeclr(idxleft, id, type));
            RESULT = atl;
        :}
    ;

FArgsTypeList ::=
        {:
            RESULT = new ArrayList<Node>();
        :} 
    | COMMA IDENTIFIER:id COLON FnType:type FArgsTypeList:atl
        {:
            atl.add(0, new XiDeclr(idxleft, id, type));
            RESULT = atl;
        :}
    ;

ReturnTypeList ::= 
    FnType:type FReturnTypeList:rtl
        {:
            rtl.add(0, type);
            RESULT = rtl;
        :}
    ;

FReturnTypeList ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | COMMA FnType:type FReturnTypeList:rtl
        {:
            rtl.add(0, type);
            RESULT = rtl;
        :}
    ;

FnType ::= 
    INT:i
        {:
            RESULT = new XiType(ixleft, "int");
        :}
    | BOOL:b
        {:
            RESULT = new XiType(bxleft, "bool");
        :}
    | FnType:type LBRACK RBRACK
        {:
            RESULT = new XiType(typexleft, type);
        :}
    ;
