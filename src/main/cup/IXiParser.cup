import java_cup.runtime.*;
import java_cup.runtime.ComplexSymbolFactory.*;

import java.util.List;
import java.util.ArrayList;

import lex.*;
import ast.*;
import xic.XicException;

parser code {:

    /* Exposed Interface */

    //TODO: throw XicException
    public static Node from(String source, String unit) throws XicException {
        IXiLexer lexer = IXiLexer.from(source, unit);
        IXiParser parser = new IXiParser(lexer);
        
        try {
        	return parser.parse().value();
        } catch (XicException xic) {
        	throw xic;
        } catch (Exception e) {
        	throw ParseException.internal(e);
        }
    }

    /* Private Utility Functions */

    IXiLexer lexer;

    IXiParser(IXiLexer lexer) {
        super(lexer, lexer.getSymbolFactory());
        this.lexer = lexer;
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws ParseException {
        done_parsing();
        ComplexSymbol sym = (ComplexSymbol) cur_token;
        throw new ParseException(sym);
    }

    public void syntax_error(Symbol cur_token) {}

:};

scan with {: return lexer.nextToken(); :};

/* Terminals (tokens returned by the scanner). */
terminal                    USE;
terminal                    INT, BOOL;
terminal                    LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE;
terminal                    CLASS, EXTENDS;                                 // PA7
terminal                    COLON, COMMA;
terminal    String          IDENTIFIER;

/* Non terminals */
non terminal    Node            FnDefinition;
// non terminal    List<Node>      FnDefinitionList;    // Deprecated PA7
non terminal    List<Node>      ArgsTypeList, FArgsTypeList;
non terminal    List<Node>      ReturnTypeList, FReturnTypeList;
non terminal    Node            FnType;
non terminal    Node            UseDeclr;               // PA7
non terminal    List<Node>      UseDeclarationList;     // PA7
non terminal    Node            ClassDeclr;             // PA7
non terminal    List<Node>      ClassDef;               // PA7
non terminal    List<Node>      InterfaceBody;          // PA7
non terminal    Node            Interface; 

/* The grammar rules */
start with      Interface;

// PA7
// TODO: do we need to type interfaces differently from programs?
Interface ::= UseDeclarationList:uses InterfaceBody:body
    {:
        RESULT = new Program(usesxleft, uses, body);
    :}
    ;

// PA 7 adds use declarations to interfaces
// Uses
UseDeclarationList ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | UseDeclarationList:uds UseDeclr:u
    {:
        uds.add(u);
        RESULT = uds;
    :}
    ;

// Use Declaration
UseDeclr ::= 
    USE:u IDENTIFIER:id OptSemicolon
    {:
        RESULT = new Use(uxleft, id);
    :}
    ;

// PA7
InterfaceBody ::=
    {:
        RESULT = new ArrayList<Node>();
    :}
    | FnDefinition:f InterfaceBody:body
    {:
        body.add(0,f);
        RESULT = body;
    :}
    | ClassDeclr:c InterfaceBody:body
    {:
        body.add(0,c);
        RESULT = body;
    :} 
    ;

// Class Declarations PA7 TODO
ClassDeclr ::= 
    CLASS:cls IDENTIFIER:id LBRACE ClassDef:cd RBRACE
    {:
        // RESULT = new Class(cxdleft, id, cd);
    :}
    | CLASS:cls IDENTIFIER:id EXTENDS IDENTIFIER LBRACE ClassDef:cd RBRACE
    {:
    :}
    ;

ClassDef ::= 
    {:
        RESULT = new ArrayList<Node>();
    :}
    | FnDefinition:f ClassDef:cd
    {:
        cd.add(0,f);
        RESULT = cd;
    :}
    // TODO: design choice for variables
    | GlobalVar ClassDef
    {:
        // Do we treat instance variables lexically the same as global variables?
    :}
    ;

// TODO: port class variables to interfaces 
// Need to choose between using global or a different non-terminal

// Function Definitions
FnDefinition ::= 
    IDENTIFIER:id LPAREN ArgsTypeList:atl RPAREN COLON ReturnTypeList:rtl
    {:
        RESULT = new Fn(idxleft, id, atl, rtl);
    :}
    | IDENTIFIER:id LPAREN ArgsTypeList:atl RPAREN
    {:
        RESULT = new Fn(idxleft, id, atl);
    :}
    ;

ArgsTypeList ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | IDENTIFIER:id COLON FnType:type FArgsTypeList:atl
        {:
            atl.add(0, new Declare(idxleft, id, type));
            RESULT = atl;
        :}
    ;

FArgsTypeList ::=
        {:
            RESULT = new ArrayList<Node>();
        :} 
    | COMMA IDENTIFIER:id COLON FnType:type FArgsTypeList:atl
        {:
            atl.add(0, new Declare(idxleft, id, type));
            RESULT = atl;
        :}
    ;

ReturnTypeList ::= 
    FnType:type FReturnTypeList:rtl
        {:
            rtl.add(0, type);
            RESULT = rtl;
        :}
    ;

FReturnTypeList ::= 
        {:
            RESULT = new ArrayList<Node>();
        :}
    | COMMA FnType:type FReturnTypeList:rtl
        {:
            rtl.add(0, type);
            RESULT = rtl;
        :}
    ;

// TODO: extend type
FnType ::= 
    INT:i
        {:
            RESULT = new XiType(ixleft, "int");
        :}
    | BOOL:b
        {:
            RESULT = new XiType(bxleft, "bool");
        :}
    | FnType:type LBRACK RBRACK
        {:
            RESULT = new XiType(typexleft, type);
        :}
    ;

// DEPRECATED
// FnDefinitionList ::= 
//         {:
//             RESULT = new ArrayList<Node>();
//         :}
//     | FnDefinitionList:fdl FnDefinition:f
//         {:
//             fdl.add(f);
//             RESULT = fdl;
//         :}
//     ;

// DEPRECATED
// Interface ::= FnDefinitionList:fdl FnDefinition:f
//         {:
//             fdl.add(f);
//             RESULT = new Program(fdlxleft, fdl);
//         :}
//     ;

