package assemble;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import assemble.instructions.*;
import assemble.instructions.BinOp.Kind;
import static assemble.instructions.InstrFactory.*;

import util.Either;

import xic.XicInternalException;

public class TrivialAllocator extends InstrVisitor<Void> {

    public static CompUnit<Reg> allocate(CompUnit<Temp> unit) {
        TrivialAllocator allocator = new TrivialAllocator(unit);
        return allocator.allocate();
    }

    // Unallocated CompUnit
    private CompUnit<Temp> unit;

    // Running list of allocated assembly functions
    private CompUnit<Reg> allocated;

    // Running list of allocated function instructions
    private List<Instr<Reg>> instrs;

    // Map of named temps to offset on stack
    private Map<String, Integer> tempStack;

    // Number of temps on the stack - 1
    private int tempCounter;

    // Maximum number of args to a call in current function
    private int maxArgs;

    // Maximum number of returns from a call in current function
    private int maxRets;

    // Number of words to subtract from base pointer to get location
    // in stack where multiple returns > 2 must be written by callee.
    private Mem<Reg> calleeReturnAddr;


    // Caller saved registers - not required for trivial allocation
    // private Operand r10;
    // private Operand r11;

    private TrivialAllocator(CompUnit<Temp> unit) {
        this.unit = unit;
        this.allocated = new CompUnit<>();
        this.tempStack = null;
        this.instrs = null;
        this.tempCounter = 0;
        this.maxArgs = 0;
        this.maxRets = 0;
        this.calleeReturnAddr = null;
    }

    /**
     * Push a named temp to the stack.
     */
    private Mem<Reg> pushTemp(String name) {
        tempStack.put(name, tempCounter++);
        return getTemp(name);
    }

    /**
     * Push an unnamed temp to the stack and return the mem operand.
     */
    private Mem<Reg> pushTemp() {
        Mem<Temp> temp = Mem.of(Temp.RBP, -normalize(++tempCounter));
        return Mem.allocate(temp, Reg.RBP);
    }

    /**
     * Get the mem operand to a temp on the stack.
     * Equivalent to -(i+1)*8(%rbp) where name -> i in the tempStack
     * +1 to offset for saved base pointer
     */
    private Mem<Reg> getTemp(String name) {
        if (tempStack.containsKey(name)) {
            Mem<Temp> temp = Mem.of(Temp.RBP, -normalize(tempStack.get(name) + 1));
            return Mem.allocate(temp, Reg.RBP);
        }
        throw XicInternalException.runtime("Non-existent temp generated by Tiler.");
    }

    /**
     * Multiply by the word size to get offset for a memory location.
     */
    private int normalize(int i) {
        return i * Config.WORD_SIZE;
    }

    /* Recursive descent visitors */

    private CompUnit<Reg> allocate() {
        for (FuncDecl<Temp> fn : unit.fns) {
            allocate(fn);
        }
        return allocated;
    }

    private void allocate(FuncDecl<Temp> fn) {
        FuncDecl<Reg> allocatedFn = new FuncDecl.R(fn);
        instrs = new ArrayList<>();
        tempStack = new HashMap<>();
        tempCounter = 0;
        maxArgs = 0;
        maxRets = 0;
        calleeReturnAddr = null;

        // Set CALLEE_RET_ADDR to a temp on stack
        if (fn.rets > 2) {
            calleeReturnAddr = pushTemp();
        }

        for (Instr<Temp> i : fn.stmts) {
            i.accept(this);
        }

        allocatedFn.stmts = instrs;
        allocated.fns.add(allocatedFn);

        // Calculate words to shift rsp, +1 to offset tempCounter
        int rsp = tempCounter + maxArgs + maxRets + 1;
        // 16 byte alignment
        rsp = rsp % 2 == 1 ? rsp + 1 : rsp;
        Imm shift = new Imm(normalize(rsp));

        // Insert stack setup
        BinOp.RIR sub = new BinOp.RIR(Kind.SUB, shift, Reg.RSP);
        allocatedFn.prelude.set(allocatedFn.prelude.size() - 1, sub);

        // Insert stack teardown
        BinOp.RIR add = new BinOp.RIR(Kind.ADD, shift, Reg.RSP);
        allocatedFn.epilogue.set(2, add);
    }

    /*
     * BinOp Visitors
     */

    public Void visit(BinOp.TIR b) {

        Either<Reg, Mem<Reg>> dest = allocate(b.dest);

        // Move register into register
        if (dest.isLeft()) {
            instrs.add(new BinOp.RIR(b.kind, b.src, dest.getLeft()));
        }
        
        // Move register into mem
        else {
            instrs.add(new BinOp.RIM(b.kind, b.src, dest.getRight()));
        }

        return null;
    }

    public Void visit(BinOp.TIM b) {
        Mem<Reg> dest = allocate(b.dest);
        instrs.add(new BinOp.RIM(b.kind, b.src, dest));
        return null;
    }

    public Void visit(BinOp.TRM b) {
        Either<Reg, Mem<Reg>> src = allocate(b.src);
        Mem<Reg> dest = allocate(b.dest);

        // Move register into memory
        if (src.isLeft()) {
            instrs.add(new BinOp.RRM(b.kind, src.getLeft(), dest));
        }

        // Move memory into register, then into memory
        else {
            instrs.add(new Mov.RMR(src.getRight(), Reg.R9));
            instrs.add(new BinOp.RRM(b.kind, Reg.R9, dest));
        }
        
        return null;
    }

    public Void visit(BinOp.TMR b) {
        Mem<Reg> src = allocate(b.src);
        Either<Reg, Mem<Reg>> dest = allocate(b.dest);

        // Move memory into register
        if (dest.isLeft()) {
            instrs.add(new BinOp.RMR(b.kind, src, dest.getLeft()));
        }

        // Move memory into register, then into memory
        else {
            instrs.add(new Mov.RMR(src, Reg.R9));
            instrs.add(new BinOp.RRM(b.kind, Reg.R9, dest.getRight()));
        }

        return null;
    }

    public Void visit(BinOp.TRR b) {
        Either<Reg, Mem<Reg>> src = allocate(b.src);
        Either<Reg, Mem<Reg>> dest = allocate(b.dest);

        // Move register into register
        if (src.isLeft() && dest.isLeft()) {
            instrs.add(new BinOp.RRR(b.kind, src.getLeft(), dest.getLeft()));
        }

        // Move register into memory
        else if (src.isLeft()) {
            instrs.add(new BinOp.RRM(b.kind, src.getLeft(), dest.getRight()));
        }

        // Move memory into register
        else if (dest.isLeft()) {
            instrs.add(new BinOp.RMR(b.kind, src.getRight(), dest.getLeft()));
        }

        // Move memory into register, then into memory
        else {
            instrs.add(new Mov.RMR(src.getRight(), Reg.R9));
            instrs.add(new BinOp.RRM(b.kind, Reg.R9, dest.getRight()));
        }

        return null;
    }

    /*
     * Call Visitor
     */

    public Void visit(Call.T c) {
        maxArgs = Math.max(maxArgs, c.numArgs);
        maxRets = Math.max(maxRets, c.numRet);
        instrs.add(new Call.R(c.name, c.numArgs, c.numRet));
        return null;
    }

    /*
     * Cmp Visitors
     */

    public Void visit(Cmp.TIR c) {
        Either<Reg, Mem<Reg>> right = allocate(c.right);
        
        // Compare immediate to register
        if (right.isLeft()) {
            instrs.add(new Cmp.RIR(c.left, right.getLeft()));
        }

        // Move immediate to register, then compare to memory
        else {
            instrs.add(new Mov.RIR(c.left, Reg.R9));
            instrs.add(new Cmp.RRM(Reg.R9, right.getRight()));
        }

        return null;
    }

    public Void visit(Cmp.TRM c) {
        Either<Reg, Mem<Reg>> left = allocate(c.left);
        Mem<Reg> right = allocate(c.right);

        // Compare register to memory
        if (left.isLeft()) {
            instrs.add(new Cmp.RRM(left.getLeft(), right));
        }

        // Move memory to register, then compare to memory
        else {
            instrs.add(new Mov.RMR(left.getRight(), Reg.R9));
            instrs.add(new Cmp.RRM(Reg.R9, right));
        }

        return null;
    }

    public Void visit(Cmp.TMR c) {
        Mem<Reg> left = allocate(c.left);
        Either<Reg, Mem<Reg>> right = allocate(c.right);

        // Compare memory to register
        if (right.isLeft()) {
            instrs.add(new Cmp.RMR(left, right.getLeft()));
        }

        // Move memory to register, then compare to memory
        else {
            instrs.add(new Mov.RMR(left, Reg.R9));
            instrs.add(new Cmp.RRM(Reg.R9, right.getRight()));
        }
       
        return null;
    }

    public Void visit(Cmp.TRR c) {
        Either<Reg, Mem<Reg>> left = allocate(c.left);
        Either<Reg, Mem<Reg>> right = allocate(c.right);
        
        // Compare register to register
        if (left.isLeft() && right.isLeft()) {
            instrs.add(new Cmp.RRR(left.getLeft(), right.getLeft()));
        }

        // Compare register to memory
        else if (left.isLeft()) {
            instrs.add(new Cmp.RRM(left.getLeft(), right.getRight()));
        }

        // Compare memory to register
        else if (right.isLeft()) {
            instrs.add(new Cmp.RMR(left.getRight(), right.getLeft()));
        }

        // Move memory to register, then compare
        else {
            instrs.add(new Mov.RMR(left.getRight(), Reg.R9));
            instrs.add(new Cmp.RRM(Reg.R9, right.getRight()));
        }

        return null;
    }

    /*
     * Cqo Visitor
     */

    public Void visit(Cqo.T c) {
        instrs.add(new Cqo.R());
        return null;
    }

    /*
     * DivMul Visitors
     */

    public Void visit(DivMul.TR d) {

        Either<Reg, Mem<Reg>> reg = allocate(d.src);
        
        // DivMul a register source
        if (reg.isLeft()) {
            instrs.add(new DivMul.RR(d.kind, reg.getLeft()));
        }

        // DivMul a memory source
        else {
            instrs.add(new DivMul.RM(d.kind, reg.getRight()));
        }

        return null;
    }

    public Void visit(DivMul.TM d) {
        Mem<Reg> reg = allocate(d.src);
        instrs.add(new DivMul.RM(d.kind, reg));
        return null;
    }

    /*
     * Jcc Visitor
     */

    public Void visit(Jcc.T j) {
        instrs.add(new Jcc.R(j.kind, j.target));
        return null;
    }

    /*
     * Jmp Visitor
     */

    public Void visit(Jmp.T j) {
        instrs.add(new Jmp.R(j.label));
        return null;
    }

    /*
     * Label Visitor
     */

    public Void visit(Label.T l) {
        instrs.add(l.promote());
        return null;
    }

    /*
     * Lea Visitor
     */

    public Void visit(Lea.T l) {
        Either<Reg, Mem<Reg>> dest = allocate(l.dest);   
        Mem<Reg> src = allocate(l.src);

        // Load into register destination
        if (dest.isLeft()) {
            instrs.add(new Lea.R(src, dest.getLeft()));
        }

        // Temporarily swap using a register
        else {
            Mem<Reg> temp = pushTemp();
            instrs.add(new Mov.RRM(Reg.R9, temp));
            instrs.add(new Lea.R(src, Reg.R9));
            instrs.add(new Mov.RRM(Reg.R9, dest.getRight()));
            instrs.add(new Mov.RMR(temp, Reg.R9));
        }

        return null;
    }

    /*
     * Mov Visitors
     */

    public Void visit(Mov.TIR m) {
        Either<Reg, Mem<Reg>> dest = allocate(m.dest);

        // Move immediate into register
        if (dest.isLeft()) {
            instrs.add(new Mov.RIR(m.src, dest.getLeft()));
        }

        // Move immediate into memory
        else {
            instrs.add(new Mov.RIM(m.src, dest.getRight()));
        }

        return null;
    }

    public Void visit(Mov.TIM m) {
        Mem<Reg> dest = allocate(m.dest);
        instrs.add(new Mov.RIM(m.src, dest));
        return null;
    }

    public Void visit(Mov.TRM m) {
        Either<Reg, Mem<Reg>> src = allocate(m.src);
        Mem<Reg> dest = allocate(m.dest);

        // Move register into memory
        if (src.isLeft()) {
            instrs.add(new Mov.RRM(src.getLeft(), dest));
        }

        // Move memory into register, then into memory
        else {
            instrs.add(new Mov.RMR(src.getRight(), Reg.R9));
            instrs.add(new Mov.RRM(Reg.R9, dest));
        }

        return null;
    }

    public Void visit(Mov.TMR m) {
        Mem<Reg> src = allocate(m.src);
        Either<Reg, Mem<Reg>> dest = allocate(m.dest);

        // Move memory into register
        if (dest.isLeft()) {
            instrs.add(new Mov.RMR(src, dest.getLeft()));
        }

        // Move memory into register, then into memory
        else {
            instrs.add(new Mov.RMR(src, Reg.R9));
            instrs.add(new Mov.RRM(Reg.R9, dest.getRight()));
        }

        return null;
    }

    public Void visit(Mov.TRR m) {
        Either<Reg, Mem<Reg>> src = allocate(m.src);
        Either<Reg, Mem<Reg>> dest = allocate(m.dest);

        // Move register into register
        if (src.isLeft() && dest.isLeft()) {
            instrs.add(new Mov.RRR(src.getLeft(), dest.getLeft()));
        }

        // Move register into memory
        else if (src.isLeft()) {
            instrs.add(new Mov.RRM(src.getLeft(), dest.getRight()));
        }

        // Move memory into register
        else if (dest.isLeft()) {
            instrs.add(new Mov.RMR(src.getRight(), dest.getLeft()));
        }

        // Move memory into register, then into memory
        else {
            instrs.add(new Mov.RMR(src.getRight(), Reg.R9));
            instrs.add(new Mov.RRM(Reg.R9, dest.getRight()));
        }

        return null;
    }

    /*
     * Pop Visitors
     */

    public Void visit(Pop.TR p) {

        Either<Reg, Mem<Reg>> dest = allocate(p.dest);

        // Pop to register
        if (dest.isLeft()) {
            instrs.add(new Pop.RR(dest.getLeft()));
        }

        // Pop to memory
        else {
            instrs.add(new Pop.RM(dest.getRight()));
        }
        
        return null;
    }

    public Void visit(Pop.TM p) {
        Mem<Reg> dest = allocate(p.dest);
        instrs.add(new Pop.RM(dest));
        return null;
    }

    /*
     * Push Visitors
     */

    public Void visit(Push.TR p) {

        Either<Reg, Mem<Reg>> src = allocate(p.src);

        // Push from register
        if (src.isLeft()) {
            instrs.add(new Push.RR(src.getLeft()));
        }

        // Push from memory
        else {
            instrs.add(new Push.RM(src.getRight()));
        }
        
        return null;
    }

    public Void visit(Push.TM p) {
        Mem<Reg> src = allocate(p.src);
        instrs.add(new Push.RM(src));
        return null;
    }

    /*
     * Ret Visitor
     */

    public Void visit(Ret.T r) {
        instrs.add(new Ret.R());
        return null;
    }

    /*
     * Setcc Visitor
     */

    public Void visit(Setcc.T s) {
        instrs.add(new Setcc.R(s.kind));
        return null;
    }

    /*
     * Text Visitor
     */

    public Void visit(Text.T t) {
        instrs.add(new Text.R(t.text));
        return null;
    }

    private Either<Reg, Mem<Reg>> allocate(Temp t) {
        String name = t.name;
        switch (t.kind) {
            // Allocate an ordinary temporary
            case TEMP:
                if (!tempStack.containsKey(name)) {
                    return Either.right(pushTemp(name));
                }
                return Either.right(getTemp(name));

            // Get the fixed register
            case FIXED:
                return Either.left(t.getRegister());
        }
        assert false;
        return null;
    }

    /**
     * Guaranteed to eliminate recursive memory access via spilling.
     */
    private Mem<Reg> allocate(Mem<Temp> mem) {
        switch (mem.kind) {

        case R:
            // Spill reg if necessary
            Either<Reg, Mem<Reg>> reg = allocate(mem.reg);

            if (reg.isRight()) {
                instrs.add(new Mov.RMR(reg.getRight(), Reg.R10));
                reg = Either.left(Reg.R10);
            }

            return Mem.of(reg.getLeft());

        case RO:
            // Spill reg if necessary
            reg = allocate(mem.reg);

            if (reg.isRight()) {
                instrs.add(new Mov.RMR(reg.getRight(), Reg.R10));
                reg = Either.left(Reg.R10);
            }

            return Mem.of(reg.getLeft(), mem.offset);

        case RSO:
            // Spill reg if necessary
            reg = allocate(mem.reg);

            if (reg.isRight()) {
                instrs.add(new Mov.RMR(reg.getRight(), Reg.R10));
                reg = Either.left(Reg.R10);
            }

            return Mem.of(reg.getLeft(), mem.offset, mem.scale);

        case BRSO:
            // Spill base if necessary
            Either<Reg, Mem<Reg>> base = allocate(mem.base);

            if (base.isRight()) {
                instrs.add(new Mov.RMR(base.getRight(), Reg.R11));
                reg = Either.left(Reg.R11);
            }

            // Spill reg if necessary
            reg = allocate(mem.reg);

            if (reg.isRight()) {
                instrs.add(new Mov.RMR(reg.getRight(), Reg.R10));
                reg = Either.left(Reg.R10);
            }

            return Mem.of(base.getLeft(), reg.getLeft(), mem.offset, mem.scale);
        }

        // Unreachable
        assert false;
        return null;
    }
}
